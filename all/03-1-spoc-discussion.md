# lec5 SPOC思考题

##**提前准备**
（请在上课前完成）

- 完成lec５的视频学习和提交对应的在线练习
- git pull ucore_os_lab, v9_cpu, os_course_spoc_exercises in github repos。这样可以在本机上完成课堂练习。
- 理解连续内存动态分配算法的实现（主要自学和网上查找）

NOTICE
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。


## 思考题
---

## “连续内存分配”与视频相关的课堂练习

### 5.1 计算机体系结构和内存层次

1.操作系统中存储管理的目标是什么？

* 需要对每个程序提供独立的虚拟空间，将整个内存虚拟化，对用户提供一套相同的接口。
* 同时对内存进行保护，防止程序任意访问修改内存。
* 需要隔离物理内存和虚拟内存，将物理内存虚拟化，使得不同的程序不能够访问其他程序的内存空间。
* 对于某些地址，需要实现不同程序间的内存共享。


### 5.2 地址空间和地址生成
1.描述编译、汇编、链接和加载的过程是什么？

* 编译：编译器读入高级程序语言代码文件，进行词法分析，中间表示，代码生成，优化等步骤后给出汇编语言表示的代码或者直接生成机器码；一些尚不确定的地址使用占位的符号标记，便于之后链接的时候填充
* 汇编是将汇编代码文件翻译生成机器码二进制文件，包括代码段，数据段，bss段等等
* 链接是将不同的二进制文件拼接成为一个整体二进制文件，并将文件中一些之前没有填充好的地址等内容填充好，进行符号解析和重定位。
* 加载是将一定格式的二进制文件按照要求加载到内存中的过程，需要将各个段放在内存的相应段中并设置好地址。动态加载时需要在程序运行过程中将动态链接库加载到内存中并完成地址的设置实现链接，此时需要在加载的过程中链接，将动态库映射到相应的地址空间。最终跳转到程序入口点，启动程序。

2.动态链接如何使用？尝试在Linux平台上使用LD_DEBUG查看一个C语言Hello world的启动流程。  (optional)

运行 `LD_DEBUG=all ./test` 后发现主要有以下过程：

* 查找 libc 库并重定位
* 找到相应的符号，保证函数调用可以找到库中相应的函数
* 初始化程序，将控制权交给 test
* 调用相应函数输出结果
* 调用 exit 退出

### 5.3 连续内存分配
1. 什么是内碎片、外碎片？

   内碎片是指因为分配内存时有对齐或者最小页大小的限制，使程序被分配了超过所需要空间的内存空间，造成一部分内存空间被浪费。

   外碎片是指因为不同程序在运行中不断分配释放内存，造成在不同的内存块之间的一些空间不够继续分配给进程的内存空间。

2. 最先匹配会越用越慢吗？请说明理由（可来源于猜想或具体的实验）？

   会。因为最先匹配按照地址从低到高顺序组织链表，并在第一次找到可用块的时候分配内存。在开始的时候一直在低地址空间分配内存，在后期分配内存时由于低地址空间被分配的差不多了，需要沿着链表找很久才能在高地址空间找到合适的内存块，从而越用越慢。

3. 最差匹配的外碎片会比最优适配算法少吗？请说明理由（可来源于猜想或具体的实验）？

   会。因为最优匹配每次都选择剩余空间最小的内存块进行内存分配，很容易导致最后分配剩下的内存块过小以至于无法再被任何程序分配获取，产生大量外碎片；而最差匹配每次都选择剩余空间最大的块进行分配，这样分配剩下的新块的大小海足够大，一般可以被继续分配，从而大大减少了内存碎片。

4. 理解0:最优匹配，1:最差匹配，2:最先匹配，3:buddy system算法中分区释放后的合并处理过程？ (optional)

   将内存块按照地址从低到高的顺序组织起来，在释放的时候先扫描链表找到释放内存块的位置，之后检查链表中相邻的内存块是否地址相邻，如果可以合并则合并。

   buddy system 的思路类似，释放内存块在相对应的链表中查询所有内存块看能否合并，如果合并则从当前链表中取出合并后的内存块插入更大内存块的链表中，继续检查能否合并重复该过程直到不能再合并。


### 5.4 碎片整理
1.对换和紧凑都是碎片整理技术，它们的主要区别是什么？为什么在早期的操作系统中采用对换技术？ 

* 对换是将内存与外存中的内容进行交换，具体来说就是将内存中的进程交换到外部存储中，这样几句释放出了内存空间，减少了碎片；
* 紧凑是在内存中将已经分配好的内存块进行整理搬移，在这个过程之需要处理程序内部的地址问题。
* 因为对换不需要考虑内存块中地址如何处理，对换前后程序的虚拟地址对应的物理地址不变，实现简单；而紧凑需要考虑搬移内存块后内存中的地址问题，实现复杂。

2.一个处于等待状态的进程被对换到外存（对换等待状态）后，等待事件出现了。操作系统需要如何响应？

操作系统首先尝试唤醒程序，发现程序被交换到了外存中，于是先从外存中将程序交换回内存（可能涉及到页替换机制），之后将该进程的状态由等待改到就绪，加入就绪队列并响应等待事件。之后该程序就可以被调度执行了。

### 5.5 伙伴系统
1. 伙伴系统的空闲块如何组织？

   对于相同大小的块采用链表进行组织，对于不同大小的块，采用不同的链表进行组织，这些链表的地址以哈希表的形式放在一起，便于OS快速查找到相应链表。

2. 伙伴系统的内存分配流程？伙伴系统的内存回收流程？

   分配时根据所请求的内存块大小查找最小满足要求的内存块的链表，如果有空闲块则分配，如果没有则向更大一级的内存块链表请求，直到某一级内存链表中分配内存空间。如果分配的内存空间比需求空间的二倍还大，则不断将该内存空间二分，将空闲块插入相应链表，最后分配给程序适当大小的内存。

回收是分配的逆过程，将释放的内存块插入相应大小内存块链表中，遍历链表查找是否能够合并。如果合并则将内存块取出，插入更大一级内存块链表中重复该过程。

## 课堂实践

观察最先匹配、最佳匹配和最差匹配这几种动态分区分配算法的工作过程，并选择一个例子进行分析分析整个工作过程中的分配和释放操作对维护数据结构的影响和原因。

  * [算法演示脚本的使用说明](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep3-malloc.md)
  * [算法演示脚本](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep3-malloc.py)

例如：
```
python ./ostep3-malloc.py -S 100 -b 1000 -H 4 -a 4 -l ADDRSORT -p BEST -n 5 -c
python ./ostep3-malloc.py -S 100 -b 1000 -H 4 -a 4 -l ADDRSORT -p FIRST -n 5 -c
python ./ostep3-malloc.py -S 100 -b 1000 -H 4 -a 4 -l ADDRSORT -p WORST -n 5 -c
```

### 扩展思考题 (optional)

1. 请参考xv6（umalloc.c），ucore lab2代码，选择四种（0:最优匹配，1:最差匹配，2:最先匹配，3:buddy systemm）分配算法中的一种或多种，在Linux应用程序/库层面，用C、C++或python来实现malloc/free，给出你的设计思路，并给出可以在Linux上运行的malloc/free实现和测试用例。


2. 阅读[slab分配算法](http://en.wikipedia.org/wiki/Slab_allocation)，尝试在应用程序中实现slab分配算法，给出设计方案和测试用例。
