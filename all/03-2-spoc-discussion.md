# lec6 SPOC思考题


NOTICE
- 有"w3l2"标记的题是助教要提交到学堂在线上的。
- 有"w3l2"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。

## 与视频相关思考题

### 6.1	非连续内存分配的需求背景
 1. 为什么要设计非连续内存分配机制？

    将程序需要的连续虚拟内存空间映射到不连续的物理内存空间上，一方面更加灵活，不限制程序虚拟空间的分配，程序面对的虚拟内存可以认为是独占的，不用考虑其他程序的影响；

    另一方面这样可以有效的减少内存分配中的外碎片，提高内存利用效率；

    分离虚拟内存与实际物理内存，便于访问控制与内存共享。

 2. 非连续内存分配中内存分块大小有哪些可能的选择？大小与大小是否可变?

 3. 为什么在大块时要设计大小可变，而在小块时要设计成固定大小？小块时的固定大小可以提供多种选择吗？

      大小可变更加灵活，固定大小则易于实现和管理。

  

### 6.2	段式存储管理

 1. 什么是段、段基址和段内偏移？

    段是程序中一段连续的内存空间的抽象，通过段我么可以描述一段连续的物理空间，并进行越界检查和访问控制。

    段基址是段的起始位置，段内偏移是指该地址相对段基址的偏移，最终线性地址为段基址+段内偏移。

 2. 段式存储管理机制的地址转换流程是什么？为什么在段式存储管理中，各段的存储位置可以不连续？这种做法有什么好处和麻烦？

    一个逻辑地址中包含了段选择子和段内偏移，通过段选择子查询到段基址和段的访问权限等等信息，之后通过段基址+段内偏移得到线性地址。

    因为段基址决定了一个段描述一段逻辑连续的内存空间，不同段之间没有联系，因此不会有跨段访问，跨段访问也是非法操作，段的相对位置不会影响程序的正确执行。

    这种做法一方面将内存抽象出来了，一方面增加了对内存访问的保护，便于管理。分散的物理空间也减少了浪费，提高了灵活性。但是这样也增加了访存的成本，需要去查询段表才能进行地址转换，每次需要访问两次内存。

### 6.3	页式存储管理
 1. 什么是页（page）、帧（frame）、页表（page table）、存储管理单元（MMU）、快表（TLB, Translation Lookaside Buffer）和高速缓存（cache）？

    页是页机制内存分配的基本单位，每次分配最小的单元就是一个页。一个页也是虚拟地址与物理地址连续对应的基本单元。

    页是虚拟内存的概念，而页帧（frame）是物理内存的概念，页和页帧对应。

    页表是记录内存中页与页帧对应关系的表，每个页占页表中的一项。

    MMU 是 CPU 中负责内存地址转换的单元，会在启动段页机制后自动查询内存中的段表和页表进行逻辑地址->线性地址->物理地址的转换，并进行访问合法性和权限检查。

    TLB 是 页表的cache，缓存一部分页表，加快查询速度。

    cache是内存中数据的缓存，提高访问速度，分为指令cache和数据cache。

 1. 页式存储管理机制的地址转换流程是什么？为什么在页式存储管理中，各页的存储位置可以不连续？这种做法有什么好处和麻烦？

    根据线性地址中包含的页号和页内偏移，通过页号查询页表获得物理基地址，加上偏移就是物理地址。因为虚拟的页与物理的页帧的对应是可以变化的，可以不连续的，虽然在页内还是顺序对应的。

    这种做法提高了灵活性，安全性，增加了内存利用效率；但是同样由于需要地址转换，增加了访问开销。


### 6.4	页表概述
 1. 每个页表项有些什么内容？有哪些标志位？它们起什么作用？

    ```
    |<------ 31~12------>|<------ 11~0 --------->| 比特
                         |b a 9 8 7 6 5 4 3 2 1 0|
    |--------------------|-|-|-|-|-|-|-|-|-|-|-|-| 占位
    |<-------index------>| AVL |G|P|D|A|P|P|U|R|P| 属性
                                 |A|   |C|W|/|/|
                                 |T|   |D|T|S|W|
    ```

    表示该页是否有效，读写权限，权限是用户态权限还是核心态权限，是否被访问过，是否被写过等等

 1. 页表大小受哪些因素影响？

    受到页的大小，内存空间的大小，当前进程数量的影响；

    也受到页表组织方式的影响，如多级页表，反向页表等等。


### 6.5	快表和多级页表
 1. 快表（TLB）与高速缓存（cache）有什么不同？

    TLB 是页表的缓存，cache是数据和代码的缓存

 1. 为什么快表中查找物理地址的速度非常快？它是如何实现的？为什么它的的容量很小？

    因为TLB 将目前常用的页表项缓存在CPU 的 sram 中，访问延迟低。通过sram实现，组织方式也应该有多种，如全相连，分组相连等等。因为CPU中晶体管数量限制，同时增加容量导致访问延迟增加，能耗增加。

 1. 什么是多级页表？多级页表中的地址转换流程是什么？多级页表有什么好处和麻烦？

    多级页表是将虚拟地址分成三段，页表分成两级，页目录表中的项指向相应地址范围的页表基地址，页表项指向相应的物理页帧。

    转换时根据虚拟地址的页目录index查找到相应的页表基地址，再根据页表index查找到相应的页表项，取出物理页基地址后加上页内偏移得到物理地址。

    好处是可以懒惰加载页表，在内存空间很大时减少页表的大小。麻烦在于地址转换复杂程度进一步增加，需要多次访存。


### 6.6	反置页表
 1. 页寄存器机制的地址转换流程是什么？

    对逻辑地址进行 hash，到相应位置查找对应的页寄存器，检查是否冲突。如果没有冲突说明找到了相应的物理地址，转换完成

 1. 反置页表机制的地址转换流程是什么？

    对逻辑地址和进程id进行 hash，之后到相应位置查看进程id和虚拟页号是否对应，如果不对应则在链表中顺序查找。找到后即完成地址转换。

 1. 反置页表项有些什么内容？

  进程id，虚拟页号，标志位。

### 6.7	段页式存储管理

 1. 段页式存储管理机制的地址转换流程是什么？这种做法有什么好处和麻烦？

    虚拟地址先通过段机制转换成线性地址，再通过页机制转换为物理地址。

    好处是管理具备段和页机制的优点，安全性好，灵活。

    麻烦是地址转化需要多次访存，开销很大。

 1. 如何实现基于段式存储管理的内存共享？

    设置一个专用的共享段，程序都具有访问共享段的权限，将需要共享的数据放在这里。对于所有的程序，这个段的内存映射都是相同的即可。

 1. 如何实现基于页式存储管理的内存共享？

    需要将相关进程中需要共享的虚拟页指向相同的物理页。如果业内存在不需要共享的内容就没法操作了，所以要将需要共享的内容单独放在专门的共享页中。

## 个人思考题
（1） (w3l2) 请简要分析64bit CPU体系结构下的分页机制是如何实现的

在 64 位体系结构下，如果采用 64位物理地址，那么总共可以寻址 2\^64 字节的空间，太大了，没有实际价值。

我们目前的 64位 CPU 只实现了48位虚拟地址。分页寻址上采用了四级页表，页表项占64bit，每级的寻址长度为9位，页面大小为4KB。因为每个页上只能放512个页表项，因此为了寻址 48 位地址对应的物理空间需要四级页表。

## 小组思考题
（1）(spoc) 某系统使用请求分页存储管理，若页在内存中，满足一个内存请求需要150ns (10\^-9s)。若缺页率是10%，为使有效访问时间达到0.5us(10\^-6s),求不在内存的页面的平均访问时间。请给出计算步骤。

150*0.9 + 0.1x = 500 => x = 3650 (ns) = 3.65 us

（2）(spoc) 有一台假想的计算机，页大小（page size）为32 Bytes，支持32KB的虚拟地址空间（virtual address space）,有4KB的物理内存空间（physical memory），采用二级页表，一个页目录项（page directory entry ，PDE）大小为1 Byte,一个页表项（page-table entries
PTEs）大小为1 Byte，1个页目录表大小为32 Bytes，1个页表大小为32 Bytes。页目录基址寄存器（page directory base register，PDBR）保存了页目录表的物理地址（按页对齐）。

PTE格式（8 bit） :
```
  VALID | PFN6 ... PFN0
```
PDE格式（8 bit） :
```
  VALID | PT6 ... PT0
```
其
```
VALID==1表示，表示映射存在；VALID==0表示，表示映射不存在。
PFN6..0:页帧号
PT6..0:页表的物理基址>>5
```
在[物理内存模拟数据文件](./03-2-spoc-testdata.md)中，给出了4KB物理内存空间的值，请回答下列虚地址是否有合法对应的物理内存，请给出对应的pde index, pde contents, pte index, pte contents。
```
1) Virtual Address 6c74
   Virtual Address 6b22
2) Virtual Address 03df
   Virtual Address 69dc
3) Virtual Address 317a
   Virtual Address 4546
4) Virtual Address 2c03
   Virtual Address 7fd7
5) Virtual Address 390e
   Virtual Address 748b
```

比如答案可以如下表示： (注意：下面的结果是错的，你需要关注的是如何表示)
```
Virtual Address 7570:
  --> pde index:0x1d  pde contents:(valid 1, pfn 0x33)
    --> pte index:0xb  pte contents:(valid 1, pfn 0x61)
      --> Translates to Physical Address 0xc34 --> Value: 16

Virtual Address 21e1:
  --> pde index:0x8  pde contents:(valid 0, pfn 0x7f)
      --> Fault (page directory entry not valid)

Virtual Address 7268:
  --> pde index:0x1c  pde contents:(valid 1, pfn 0x5e)
    --> pte index:0x13  pte contents:(valid 1, pfn 0x65)
      --> Translates to Physical Address 0xca8 --> Value: 16
```

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，请说明原因。



```
1) Virtual Address 6c74
      --> pde index:0x1b  pde contents:(valid 1, pfn 0x20)
        --> pte index:0x3  pte contents:(valid 1, pfn 0x61)
          --> Translates to Physical Address 0xc34 --> Value: 0x06
   Virtual Address 6b22
      --> pde index:0x1a  pde contents:(valid 1, pfn 0x52)
        --> pte index:0x19  pte contents:(valid 1, pfn 0x47)
          --> Translates to Physical Address 0x8e2 --> Value: 0x1a   
2) Virtual Address 03df
   Virtual Address 69dc
3) Virtual Address 317a
   Virtual Address 4546
4) Virtual Address 2c03
   Virtual Address 7fd7
5) Virtual Address 390e
   Virtual Address 748b
```



（3）请基于你对原理课二级页表的理解，并参考Lab2建页表的过程，设计一个应用程序（可基于python、ruby、C、C++、LISP、JavaScript等）可模拟实现(2)题中描述的抽象OS，可正确完成二级页表转换。

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，提交你的实现，并说明区别。

（4）假设你有一台支持[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)的机器，请问你如何设计操作系统支持这种类型计算机？请给出设计方案。

 (5)[X86的页面结构](http://os.cs.tsinghua.edu.cn/oscourse/OS2018spring/lecture06)
---

## 扩展思考题

阅读64bit IBM Powerpc CPU架构是如何实现[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)，给出分析报告。


## interactive　understand VM

[Virtual Memory with 256 Bytes of RAM](http://blog.robertelder.org/virtual-memory-with-256-bytes-of-ram/)：这是一个只有256字节内存的一个极小计算机系统。按作者的[特征描述](https://github.com/RobertElderSoftware/recc#what-can-this-project-do)，它具备如下的功能。
 - CPU的实现代码不多于500行；
 - 支持14条指令、进程切换、虚拟存储和中断；
 - 用C实现了一个小的操作系统微内核可以在这个CPU上正常运行；
 - 实现了一个ANSI C89编译器，可生成在该CPU上运行代码；
 - 该编译器支持链接功能；
 - 用C89, Python, Java, Javascript这4种语言实现了该CPU的模拟器；
 - 支持交叉编译；
 - 所有这些只依赖标准C库。

针对op-cpu的特征描述，请同学们通过代码阅读和执行对自己有兴趣的部分进行分析，给出你的分析结果和评价。
